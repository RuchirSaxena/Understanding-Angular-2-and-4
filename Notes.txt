
NPM Commands
==================

npm install -g @angular/cli  =>Install Angular CLI globally
ng --version => For checking the installed CLI Version
ng new hello-world => For Creating new Project ie.hello-world
ng serve => To run the server that will start live server to run our angular application => This will create localhost:4200 and we can run our application in browser

Folder Structure
===================
1.e2e =>It stands for End to End (Used for testing) , We use this folder files to test our application , basically automated test that dipicts a real user , So we can write code to launch our browser , click links , and other tests

2.node_modules =>It stores all the thrid party library on which our project depends upon , it is Used only in the development time and parts of this part of this folder are used while deploying our application

3.src =>It contains the actual source code of our project , it contains module and componets , so every application contains atleat one module or folder

4.assests => Images , icons etc.

5.enviroments =>It has one file for production enviroment and the other for the development enviroment

6.index.html =>its a simple HTML file that contails our angular application 
            Note: We dont have any references to script and css links , these references are dynamically inserted in this file

7.main.ts =>its a starting point of our application , its basically the main methood(similar to C#) ie. our start code file  , so in this file we are bootsraping the main module of our application ie.platformBrowserDynamic().bootstrapModule(AppModule)

8.polyfills.ts => This file includes polyfills(scripts) that are needed by Angular as angular contains some features of javascript that are not implemented in all the browser (converting some features of javscript that are not available in all the browser but are neede by angular js)

9.test.ts => For setting the testing enviroment for our angular app

10..editorconfig => Used for same settings if all the many developers are working on same project

11.protractor.config.js =>For test settings

12.tslint.json => For giving suggestions for our typescript code , balically similar to jslint
          


***********************Angular Fundamentals *********************

Components
============
At the heart of angular app we have one or more Components infact it is mandatory to have 1 component in angular app

What are Components?
Ans. A component is made up of 3 things :
1.Data 
2.HTML Template
3.Logic

Angular focuses on Component Model which are small parts of an application which can be re-used in same application or different applications as well.

A real world angular app is a tree of components strating from root component(App component) and other child components.

Modules
=========
1.A module is a container of group of related components

Eg:Courses Module , Admin Module 

Steps for Creating a Component
==============================
1.Create a Component.
import {Component} from '@angular/core'

//Decorator function =>Adding one or more property for defining which part of angular component we want to use in our CoursesComponent
@Component({
    selector:'courses', //<courses> "courses" , <div class="courses"></div> ".courses" ,<div id="courses"></div> "#courses"
    
    //The rendered HTMl we want
    template:'<h2>Courses</h2>'
})
export class CoursesComponent{

}

2.Register in a module.
import {CoursesComponent} from "./courses.component"

@NgModule({
  declarations: [
    AppComponent,
    CoursesComponent

  ],
3.Add an element in an HTML markup
In Html file
<h1>Basic Angular Component</h1>
<courses></courses> =>Name of selector

CLI Command for above steps
============================
In the terminal window use below Command =>

ng g c course => This Command will create below files automatically

  create src/app/admin/admin.component.html (24 bytes)
  create src/app/admin/admin.component.spec.ts (621 bytes)
  create src/app/admin/admin.component.ts (265 bytes)
  create src/app/admin/admin.component.css (0 bytes)
  update src/app/app.module.ts (468 bytes)


Data Binding in angular
============================
So , basically we have a template property in @component and we have a ts class so properties defined in the ts class can be be accessed in the Template property using {{}} and any change in the property defined in in the ts class will result change in the value of this property binded inside the Template  

Eg:
@Component({
    selector:'courses', //<courses> "courses" , <div class="courses"></div> ".courses" ,<div id="courses"></div> "#courses"
    
    //The rendered HTMl we want
    template:'<h2>{{title}}</h2>'
})
export class CoursesComponent{
    title ="List of Courses"
} 

change in the title will automatically reflected in the tempate property


Services 
==============
When we want to re-use some logic of our application in multiple places , then we should create a service , its a plain TS class with no decorators

Benefits :
1.Re-use of the logic.
2.SOC(Seperation of concern) is acheived.
3.Easy to unit test application.
4.When we Register a Dependency in a providers , then only a single instance of that class for that entire module 
Eg: 1 service will be used by 10 modules but only single intance of that service is created in our application (Also called as sigleton pattern)

Steps for Creating Service
=============================
1.Create a TS Class =>CoursesService

//There is no decorator for service ts class in angular js
export class CoursesService{
    getCourses(){
        return  [".NET Courses", "Angular JS", "React JS"];
    }
}

2.Use service in our Component Class constructor

constructor(){
        let service=new CoursesService;
        this.courses=service.getCourses();
    }

But above code is tightly coupled , we should use Dependency Injection concept to achive Decoupling

a=> Passing the Service through the constructor

  constructor(service:CoursesService){
       // let service=new CoursesService; //Tightly coupled by using new operator
        this.courses=service.getCourses();
    }

b=>Register the dependent service in the app.module inside providers property that takes array of arguments

 providers: [
    //Implemting DI 
    CoursesService
  ]

CLI Command for Creating Service

ng g s email  => Will create below files

 create src/app/email.service.spec.ts (368 bytes)
  create src/app/email.service.ts (111 bytes)

Ways of binding properties of component TS class property to Template
==============================================================
1. String Interpolation => TWo way binding , ie change in the TS Class will be refelected in the DOM but not vice versa and dom updation will happen.
Eg:

 <h2>{{ title }}</h2>


2. Property Binding =>
Eg:
  <h2 [textContent]="title"></h2>

  <img [src]="data" />
Note : Property Binding is one way compared to String Interpolation which is 2 way  


Adding Bootstrap library to Project
====================================
1.Add Bootstrap library to project using below Command.
npm install bootstrap --save 
It will be added under node_modules folder inside bootstrap folder

2.Import it to style.css file inside src folder using below code

@import "~bootstrap/dist/css/bootstrap.css";


Class Binding
==================
We can dynamically add and remove class from our HTML element by using Class Binding mechanism of Angular JS

Eg:
<input class="btn btn-primary" [class.active]="isActive" type="button" value="click me"/>

export class CoursesComponent {
    title = "List of Courses1"
    courses;
    colSpan=2;
    isActive=false;

}

when isActive = true then active class will be added to the Button and vice versa 

ie: isActive=true =>then
<input class="btn btn-primary active" type="button" value="click me">

Otherwise

isActive=false =>then
<input class="btn btn-primary" type="button" value="click me">


Style Binding
==================
Its similar to class binding , the code is below
Eg:
   <input type="button" [style.background-color]="isActive ? 'blue': 'green'"  value="Attribute Binding" />

Event Binding
=================
<button (click)="onSave($event)">Button Click Event</button>

 class CoursesComponent {
  
    //Binding to click event of button
    onSave($event){
        console.log("Button was clicked");
        console.log($event);
    }
}

$event is used to get the event properties
Note : To stop event bublling a concept related to javascript we can use $event.stopPropagation();

 Handling key press events in angular in a better way compared to javascript
 =================================================================
    <input type="text" (keyup.enter)="onKeyUp()" />

    export class CoursesComponent {
    //Binding KeyUp event 
    onKeyUp(){
        console.log("Enter was pressed");
    }

}

 Template Variables
 ==================
 They are used to get the value of control 
 eg: to get the value of textbox , they are created using #name 
 Note: Used in one way binding only

  <input #email type="text" (keyup.enter)="onKeyUp(email.value)" />   

 export class CoursesComponent {
    //Binding KeyUp event 
    onKeyUp(email){
        console.log("Enter was pressed");
        console.log("Value ="+email);

    }

    oR 
Two Way Binding
==================    
    Above code is only one way binding
    Better way of implementing it Using 2 way binding of angualr through property binding and $event

Eg: 
     <input  type="text" [value]="userName" (keyup.enter)="userName=$event.target.value; onKeyUp2WayBinding()" />

            OR Using NgModule
     <p>2 way binding =>Better way</p>
    <input [(ngModel)]="userName" (keyup.enter)="onKeyUp2WayBinding()" /> 
    Note : For above code to work we need to import the 
    FormsModule in our app.modules.ts 

    import {FormsModule} from '@angular/forms';

     imports: [
    BrowserModule,
    FormsModule
    ]


export class CoursesComponent {
    userName="Ruchir Saxena";

    //Binding 2 way
    onKeyUp2WayBinding(){
        console.log(this.userName);
    }

}

Pipes (Filters of Angular 1)
================================

Synatx :
 <h2>Pipes aka Filters</h2>
    {{ course.title | uppercase}} <br/>
    {{ course.rating | number:'1.2-2' }} <br/>
    {{ course.students | number }} <br/>
    {{ course.price | currency:'AUD'}} <br/>
    {{ course.releaseDate | date:'shortDate' }} <br/>



Custom Pipes
==============

Syntax :
Step1:
import { Pipe,PipeTransform} from '@angular/core';

@Pipe({
    name:'summary'
})
export class SummaryPipe implements PipeTransform{
    /*transform is a method defined inside PipeTransform Interface 
    first param : Value takes the element value on which the param is applied 
    Second param can take any no of arguments which can be further used to wirte our business logic
    */
    transform(value: string,limit?:number){
        if(!value)
            return null;
        let actualLimit=(limit)?limit : 50;
       return  value.substring(0,actualLimit)+'...';
    }
}

Step2:Register it in module

@NgModule({
  declarations: [
    SummaryPipe
  ]

Step3: Use Custom Pipe inside Component Template  

 {{ data | summary:20 }}

Reusable Components In Angular
================================
We can make componets reusable where a component can accept the property when they are defined

1.Input =>
For Sharing properties values we use Input module of angualr/core

Step 1:Using Input module of angualr/core

import { Component,OnInit ,Input } from '@angular/core';

@Component({
    selector:'favorite',
    templateUrl:'./favorite.component.html',
    styleUrls:['./favorite.component.css']
})
export class FavoriteComponent implements OnInit{
  //  @Input() isFavorite: boolean;
    //we can also define alias for our input property
    @Input('Fav') isFavorite: boolean;

    //Benefit of using alias is that if the isFavorite varible is changed to some other name like isSelected , then our functionality will be broken where this reusable component is using isFavorite varible ie.app.component.html, so alway use alias 
    //Note : But we have to manually update our favorite.component.html if the variable name is changed 
    ngOnInit(): void {
       // throw new Error("Method not implemented.");
    }

    constructor(){

    }

    onClick(){
        this.isFavorite=!this.isFavorite;
    }
   
}

OR 

Without Using Input module of angualr/core
import { Component,OnInit } from '@angular/core';

@Component({
    selector:'favorite',
    templateUrl:'./favorite.component.html',
    styleUrls:['./favorite.component.css'],
    inputs:['isFavorite']
})
export class FavoriteComponent implements OnInit{
    isFavorite: boolean;
    ngOnInit(): void {
        throw new Error("Method not implemented.");
    }

    constructor(){

    }

    onclick(){
        this.isFavorite=!this.isFavorite;
    }
   
}

Note: First Approch is better as it will not be affected by a change in the Variable name ie:  inputs:['isFavorite'] , it magically defines the isFavorite inside TS Component class and any other Variable defined with the same name will brake our functionality inside our template markup

Step 2: Inside app.component.html

<favorite [isFavorite]="post.isFavorite"></favorite>


2.@Output 
It is used to handle events or raise custom events that occures in our component and the parent coponent can be notified of that change by using the EventEmitter TS class

Step 1: Import Output module from angular core , also use @output for the event name(resgister event) along with EventEmitter TS class and then call enit method

Syntax:
import { Component,OnInit ,Input, Output, EventEmitter  } from '@angular/core';


@Component({
    selector:'favorite',
    templateUrl:'./favorite.component.html',
    styleUrls:['./favorite.component.css']
})
export class FavoriteComponent implements OnInit{
  //  @Input() isFavorite: boolean;
    //we can also define alias for our input property
    @Input('Fav') isFavorite: boolean;

    @Output() change =new EventEmitter();

    //Benefit of using alias is that if the isFavorite varible is changed to some other name like isSelected , then our functionality will be broken where this reusable component is using isFavorite varible ie.app.component.html, so alway use alias 
    //Note : But we have to manually update our favorite.component.html if the variable name is changed 
    ngOnInit(): void {
       // throw new Error("Method not implemented.");
    }

    constructor(){

    }
  //below we are passing a simple boolean value , but if required we can also pass a javascript object containing many key value pairs form our favorite TS class
   onClick(){
        this.isFavorite=!this.isFavorite;
        //below we are passing a simple boolean value , but if required we can also pass a javascript object containing many key value pairs form our favorite TS class
        //this.change.emit(this.isFavorite);
        this.click.emit({isFavorite:this.isFavorite});
    }
   
}
export interface FavoriteEventArgs{
    isFavorite :boolean
  }
Step 2:Define the event 

  <favorite [Fav]="post.isFavorite" (change)="onFavoriteChanged($event)"></favorite>
Note : $event is a build in object in angular , but here it will take all the params passed to the onFavoriteChanged() method defined in app component.

Step 3: => Create a method that will be called on the event and write your logic There....


export class AppComponent {
  title = 'angular app';
  post={
    title:"Reusable Component",
    isFavorite:true
  }
 /*
 FavoriteEventArgs => Interface for strongly typing the arguments of tis method  =>onFavoriteChanged => Good way to implemnt 
 we can also simply pass the javascript object having multiple key/value pair but we have to make then strongly typed ie args:{isFavorite:boolean} but if the object is complex then we should define interface in favorite component

 export interface FavoriteEventArgs{
    isFavorite :boolean
  }
 */
  onFavoriteChanged(args:FavoriteEventArgs){
    console.log("Favorite changed!!!");
    console.log(args.isFavorite);
  }
}

So basically when we are delaing with events in case of Reusable Components then we can conceptulise this co

Applying CSS to our component
===========================================================================

@Component({
    selector:'favorite',
    templateUrl:'./favorite.component.html',
    //3. Ways to apply css to our component 1.Seperate file using styleUrls
    //2.inline style in our component using styles property and pass array of styles
    //3.Write the style inside .html file of component using <style> tag property , though its not the recomended approach
    //The priorty  is give to the last way whichever is defined
   
    styles:[
        `
        .glyphicon{
            color: green;
        }
        `
    ],
    styleUrls:['./favorite.component.css'],
In component.html
    <!--This will override all the other css implementations-->
<style>
      .glyphicon{
            color: blue;
        }
</style>

   /* Below we have a additonal property of Angular ie. encasulation
      This is used in context with CSS application to our component
      Its a Enum ViewEncapsulation which has 3 values :
      1.Emulated => Use angular mechanism of setting style of components to its native scope ie. style applied with be only used with this component 
      2.Native => Use the built in shadow DOM feature of browser but shadow DOM is not supported in all browsers currently only supported with chaome version 57 + , safari version 10 +
    3.None=> It will not keep the style to component scope and will leakout outside of the component resulting in global scope of app.

    Note: We should use the Emulated property in todays context and whic is by default option of ViewEncapsulation
   */
    encapsulation: ViewEncapsulation.Emulated

})

ng-content & ng-container
=========================
ng-content is used to provide dynamic data that can come from our app componets , so bacically there are different ways to bind our dynamoc data to reusable component 
1.Property binding
2.ng-content 

ng-container removes the extra div we used in our app.component , to make our HTML more cleaner , its replaces the entire ng-container tag with the dynamic data

We should use ng-content where our reusable component does not have and data coming from its TS class and is mainly used for Design repetation in our main component , below is the example of that .....

In our component.html ie bootstrap-panel
<!--  <bootstrap-panel>
      <div class="heading">
        Heading dynamic
      </div>
      <div class="body">
        body dynamic
      </div>
    </bootstrap-panel> 
  
  Below is a better way of writing this code
  -->

    <bootstrap-panel>
        <ng-container class="heading">
          Heading dynamic
        </ng-container >
        <ng-container  class="body">
          body dynamic
        </ng-container >
      </bootstrap-panel>

Note : Here we are using select Attribute to differenciate between 2 ng-componet and if we have only 1 ng-content , then select Attribute is not required

In app.component.html =>
  <bootstrap-panel>
      <div class="heading">
        Heading dynamic
      </div>
      <div class="body">
        body dynamic
      </div>
    </bootstrap-panel>


Directives
===========================================================================
Directives are used to modify the content of our DOM , there are 2 types of Directives in angular

1.Structural =>Modify Structure of DOM

2.Attribute =>Modify Attributes of DOM elements

Syntax:

<!--
  Angular 2 way
-->
<div *ngIf="coursesCount()">
  <h1>List of courses</h1>
</div>

<div *ngIf="courses.length==0">

  <h2>No courses</h2>
</div>

<!--
  Angular 4 way
-->
<div *ngIf="coursesCount(); else noCourses">

  <h2>List of courses</h2>
</div>
<ng-template #noCourses>

  <h1>No courses</h1>
</ng-template>
<!--
  Another way in Angular 4 of writing the same code
-->
<div *ngIf="coursesCount(); then coursesList else noCoursesPresent"></div>
<!--1st Template-->
<ng-template #coursesList>
  <h2>List of courses</h2>
</ng-template>
<!--2st Template-->
<ng-template #noCoursesPresent>
  <h1>No courses</h1>
</ng-template>

In componet
export class SampledirectiveComponent  {
   courses=[];

   coursesCount():boolean{
      if(this.courses.length>0){
        return true;
      }else{
        return false;
      }
   }
}

[hidden]
==========
This Directive is to to hide the element in the dom but the HTML of that element will be present in the DOM

Usage ngIf and hidden
========================
Use *ngIf =>for large elements tree
use [hidden] => for small element trees

Note : if there is a costly operations involved in large DOM tree then use [hidden] for better performance

ngSwitch
============
Smilar to switch case of other languages

in Component.html =>

<ul class="nav nav-pills">
    <li [class.active]="viewMode=='map'">
      <a  (click)="viewMode='map'"
      >Map View</a>
    </li>
    <li [class.active]="viewMode=='list'">
      <a  (click)="viewMode='list'"
      >List View</a>
    </li>
  </ul>
  <div [ngSwitch]="viewMode">
      <div 
      *ngSwitchCase="'map'"
      >Map View Component</div>
      <div
      *ngSwitchCase="'list'"
      >List View Component</div>
      <div
      *ngSwitchDefault
      >Default View Component</div>
      
  </div>

In TS Class=>

export class SampledirectiveComponent  {
  
   viewMode:string='map';
   
}

ngFor
=======
Used as for loop 

<table class="table table-stripped">
    <tr>
      <th>S.NO</th>
      <th>Name</th>
      <th>Duration</th>
    </tr>
    <tr *ngFor="let course of coursesData; index as i ;even as isEvenRow"  [class.active]="isEvenRow==true">

    OR
    //using track by to impove performance
     <tr *ngFor="let course of coursesData; trackBy:trackCourse ;index as i ;even as isEvenRow"  [class.active]="isEvenRow==true">


      <td>{{i}}</td>
      <td>{{course.name}}</td>
      <td>{{course.duration}}</td>
      <td><button class="btn btn-danger" (click)="onDelete(course)">Delete</button></td>
    </tr>
  </table>


  export class SampledirectiveComponent  {
   courses=[];
   viewMode:string='map';
   coursesCount():boolean{
      if(this.courses.length>0){
        return true;
      }else{
        return false;
      }
   }

   coursesData=[
     {
       name:"Angular JS",
       duration:"1 month"
     },
     {
      name:"React JS",
      duration:"3 month"
     },{
      name:"Node JS",
      duration:"6 month"
     }
   ];
   onAdd(){
     this.coursesData.push({
      name:"Mongo DB",
      duration:"1 month"
     });
   }

   onDelete(course){
    this.coursesData.splice(course,1);
   }
      //USED only when we want to increace the performance of getting data from server
   trackCourse(index,course){
      return course?course.id:undefined;
   }
}

Note : We can use trackby to improve pweformance if we are getting the similar type of data from server again and again

ngClass
==========


In component.html =>
===================
<!-- [class.glyphicon-star]="isFavorite"
      [class.glyphicon-star-empty]="!isFavorite" 
                 OR

      [ngClass]="{
      'glyphicon-star':isFavorite,
      'glyphicon-star-empty':!isFavorite
      }"           
-->
In Component TS =>
export class FavoriteComponent implements OnInit{
    isFavorite: boolean;
    
    onClick(){
        this.isFavorite=!this.isFavorite;
      
    }
}

ngStyle
==========
View 72

* => In Directives
=======================
When we use the leading * ie: *ngIf ,*ngSwitch , then angular rewrites that block using ng-template

Safe Traversal operators
==========================
Basically when we are dispalying data from javascript object , so there might be scenarios where this javascript object is coming from the server and possibilites are there that this object properties are null or undifined , and that will result in the error as the object property is undifined...
To overcome this proble we should use safe Traversal operations Eg:

export class AdminComponent{
  task={
    title:'Review applications',
    assignee:null
  }
}
In above TS CLASS assignee value is null and it will result in error if we use in string manupulation
so below we are using safe Traversal operations where even if the value of assignee is null or undefined , then it will not result in error

<!--Safe Travarersal operators in angular-->
<p>
  <span *ngIf="task.assignee">{{task.assignee.name}}
  </span>
 <!-- OR -->
  <span >{{task.assignee?.name}}  </span>
</p>

Custom Directives
==================\
We can create our custom Directives in angular for implementing our specific presentation logic on DOM

CLI Command
================
ng g d InputFormat

Synatx:

import { element } from 'protractor';
import { Directive, HostListener, ElementRef, Input } from '@angular/core';

@Directive({
  selector: '[appInputFormat]'
})
export class InputFormatDirective {

  //Used ElementRef to get the value of input feilds
  constructor(private el:ElementRef) {

  }

  @Input('format') format;
  @Input('appInputFormat') format_OtherWay;
  //Imported host HostListener to get the events attached to DOM elements like blur , focus etc.
  @HostListener('focus') onfocus(){
    console.log("onFocus");
    
  }
 //Created directive to make text value to lowercase or uppercase
  @HostListener('blur') onblur(){
    console.log("onblur");
    let value:string =this.el.nativeElement.value;
    if(this.format=="lowercase")
    this.el.nativeElement.value=value.toLocaleLowerCase();
    else
    this.el.nativeElement.value=value.toUpperCase();

    if(this.format_OtherWay=="lowercase")
    this.el.nativeElement.value=value.toLocaleLowerCase();
    else
    this.el.nativeElement.value=value.toUpperCase();
    
  }
}

//In app.component.html
   
   <input type="text" name="" id="" appInputFormat [format]="'uppercase'">

<!--
    OR below way
-->

<input type="text" name="" id="" [appInputFormat]="'lowercase'">


Forms In Angular
=================
In angualr we have a class called FormControl for each control in a from which have below classes =>
1.value
2.toched
3.untoched
4.dirty =>value is changed or not
5.pritine =>Value is not changed
6.valid =>wheather value is valid or not
7.error =>If not valid , then what are the error messages

Similar to FromControl we have FromGroup which have classes for whole form ie: multiple controls are in one FromGroup and we can have multiple FromGroup in a coplex form Eg:Payment Details , Shipping Details etc.
1.value
2.toched
3.untoched
4.dirty =>value is changed or not
5.pritine =>Value is not changed
6.valid =>wheather value is valid or not
7.error =>If not valid , then what are the error messages

There are 2 ways to create these control objects :
1.Using Directive :called as Tempalte Directive Froms writing our own html code
2.Using Html code() :called as Reactive forms earlir called as model driven from

Why 2 ways"
Reactive :
1.More Control over validation logic
2.Good for complex Forms
3.Ubit Testable

Tempalte driven
1.Good for simple form
2.simple validation
3.Easier to create
4.Less code

Implemting Template driven From:
We need 2 properties for it.
1.ngModel
2.name="firstName"

Eg: 
 <div class="form-group">
    <label for="firstName">FirstName :</label>
    <input ngModel name="firstName" type="text" (change)="log(firstName)" #firstName="ngModel" id="firstName" class="form-control">
  </div>


validation For above control
================================
<div class="form-group">
    <label for="firstName">FirstName :</label>
    <input ngModel required name="firstName" type="text" (change)="log(firstName)" #firstName="ngModel"  id="firstName" class="form-control">
    <div *ngIf="firstName.touched && !firstName.valid" class="alert alert-danger">
      First Name is required
    </div>
  </div>

  Above used (change) , #firstName to pass this control to log() method ie:(change)="log(firstName)"  , next usid div for validation and placed the required message and this div will appear conditionally , Below is extended example and implementing multiple validation messages

   <div class="form-group">
    <label for="firstName">FirstName :</label>
    <input ngModel required name="firstName" type="text" (change)="log(firstName)" #firstName="ngModel" minlength="3" maxlength="10" pattern="angular"  id="firstName" class="form-control">
    <div *ngIf="firstName.touched && !firstName.valid" class="alert alert-danger">
     <div *ngIf="firstName.errors.required">First Name is required</div>
     <!--Below Using strind Interpolation for showing error messages dynamically-->
     <div *ngIf="firstName.errors.minlength">Min Length is {{firstName.errors.minlength.requiredLength}}</div>
     <div *ngIf="firstName.errors.maxlength">Max Length is 10</div>
     <div *ngIf="firstName.errors.pattern">pattern Does not match</div>
    </div>
  </div>

  Or Above code in cleaner way

   <div class="form-group">
    <label for="firstName">FirstName :</label>
    <input 
    required 
    minlength="3" 
    maxlength="10" 
    pattern="angular"  
    ngModel 
    #firstName="ngModel" 
    (change)="log(firstName)"
    name="firstName" 
    type="text" 
    id="firstName" 
    class="form-control">
    <div 
    *ngIf="firstName.touched && !firstName.valid"
     class="alert alert-danger">
     <div 
     *ngIf="firstName.errors.required">First Name is required</div>
     <div
      *ngIf="firstName.errors.minlength">Min Length is {{firstName.errors.minlength.requiredLength}}</div>
     <div 
     *ngIf="firstName.errors.maxlength">Max Length is 10</div>
     <div 
     *ngIf="firstName.errors.pattern">pattern Does not match</div>
    </div>
  </div>

  Futher we can style our controls by Adding additonal styles as angular has certain class attached to the controls depending upon its validation ie:.form-control.ng-invalid.ng-touched etc. and we can write our custom CSS on those classes
  example:
  //In component.css
  form-control.ng-invalid.ng-touched{
    border: 2px solid red;
}

ngFrom 
=========
<form #from="ngForm" (ngSubmit)="submmit(from)">
<!--
controls below
-->

 <textarea class="form-control" name="comment"
  ngModel 
  id="comment"
  cols="30" rows="10"></textarea>
</form>

Note : To have control value on submit button we need to have 2 properties on control
1.name="firstName"
2.ngModel 

For ngModelGroup for complex forms => sec 6 =>vd 85 for more info
======================================
  <div ngModelGroup="contact">
      <div class="form-group">
          <label for="firstName">FirstName :</label>
          <input 
          required 
          minlength="3" 
          maxlength="10" 
          pattern="angular"  
          ngModel 
          #firstName="ngModel" 
          (change)="log(firstName)"
          name="firstName" 
          type="text" 
          id="firstName" 
          class="form-control">
          <div 
          *ngIf="firstName.touched && !firstName.valid"
           class="alert alert-danger">
           <div 
           *ngIf="firstName.errors.required">First Name is required</div>
           <div
            *ngIf="firstName.errors.minlength">Min Length is {{firstName.errors.minlength.requiredLength}}</div>
           <div 
           *ngIf="firstName.errors.maxlength">Max Length is 10</div>
           <div 
           *ngIf="firstName.errors.pattern">pattern Does not match</div>
          </div>
        </div>

  </div>

  like above we can create multiple groups in one from 

diabling button if fromis not valid
=====================================
<form #form="ngForm" (ngSubmit)="submmit(form)">
<!--
Controls
-->
</form>

<button 
  [disabled]="!form.valid"
  class="btn btn-primary">Submmit</button>

CheckBox
=============
 <div class="checkbox">
      <label>
        <input type="checkbox" ngModel name="isSubscribed">Subscribe To Mailing List
      </label>
  </div>

DropDown
============
 <div class="form-group">
    <label for="contactMethod">Contact Method</label>
    <select name="" id="contactMethod" ngModel name="contactMethod" class="form-control">
      <option value="">select</option>
      <option *ngFor="let contactMethod of contactMethods"  [value]="contactMethod.id">{{contactMethod.name}}</option>
    </select>
  </div>

  Note: [ngValue]="contactMethod" is used to get key/value pair of ddl 
  Also we can use multiple attr to select multiple values from DDL , it will make DDL to ListBox


In TS Class
export class ContactFormComponent  {

  contactMethods= [{
    id:1,
    name:"Phone"
  },
  {
    id:2,
    name:"Email"
  },
  {
    id: 3,
    name:"Mobile No"
  }
];

}
Radio Buttons
==============
HArd code =>

  <div class="radio">
    <label>
    <input ngModel type="radio" name="customerType" value="1">
    Gold
  </label>
</div>
<div class="radio">
    <label>
        <input ngModel type="radio" name="customerType" value="2">
        Silver
    </label>
</div>

Dynamic Bind=>
  <div class="radio" *ngFor="let memberType of memberTypes">
    <label>
    <input ngModel type="radio" name="customerType" [value]="memberType.id">
    {{memberType.name}}
  </label>
</div>

In TS Class
=============
export class ContactFormComponent  {
memberTypes= [{
  id:1,
  name:"Gold"
},
{
  id:2,
  name:"Silver"
},
{
  id: 3,
  name:"Other"
}
];
}

Getting From values on HTML for testing purpose
==================================================
Below code will help us to get data from different HTML controls of Froms:

  {{form.value |json}} 

Reactive Froms
================
Creating Froms through CODE , instead of HTML markup used in template driven from

AbstractContol => Its a base class for FromControl and FromGroup ie. contains the common proerties of FromControl and FromGroup =>Inheritance concept
//Basic HTML of Form

<form>
    <div class="form-group">
        <label for="username">Username</label>
        <input 
            id="username" 
            type="text" 
            class="form-control">
    </div>
    <div class="form-group">
        <label for="password">Password</label>
        <input 
            id="password" 
            type="text" 
            class="form-control">
    </div>
    <button class="btn btn-primary" type="submit">Sign Up</button>
</form>
Now , We create above HTML from using Reactive form ie. Create above form through code

//Reactive From
<form [formGroup]="form">
    <div class="form-group">
        <label for="username">Username</label>
        <input 
            formControlName="username"
            id="username" 
            type="text" 
            class="form-control">
        <div *ngIf="form.get('username').touched && form.get('username').invalid" class="alert alert-danger">
            Username is required.
        </div>    
    </div>
    <div class="form-group">
        <label for="password">Password</label>
        <input 
            formControlName="password"
            id="password" 
            type="text" 
            class="form-control">
    </div>
    <button class="btn btn-primary" type="submit">Sign Up</button>
</form>

in TS Class=> Also import in app.module.ts =>
 import { FormsModule,ReactiveFormsModule } from '@angular/forms'

  imports: [
    FormsModule,
    ReactiveFormsModule
  ],

import { Component } from '@angular/core';
import { FormGroup, FormControl,Validators } from '@angular/forms';
@Component({
  selector: 'signup-form',
  templateUrl: './signup-form.component.html',
  styleUrls: ['./signup-form.component.css']
})
export class SignupFormComponent {
  form=new FormGroup({
    username:new FormControl('',Validators.required),
    password:new FormControl('',Validators.required)
  });

  //Further we can create below property to acess from properties in component.html
  get Username(){
    return this.form.username;
  }

}

Another example
==================
<div *ngIf="Username.touched && Username.invalid" >
                <div *ngIf="Username.errors.required" class="alert alert-danger">
                        Username is required.
                </div> 
                <div *ngIf="Username.errors.minlength" class="alert alert-danger">
                        min length is 3
                </div> 
               
        </div>   
             
    </div>
in TS=>?

 form=new FormGroup({
    username:new FormControl('',[
      Validators.required,
      Validators.minLength(3),
      Validators.maxLength(10)
    ]),
    password:new FormControl('',Validators.required)
  });    

For Futher knowlege on Froms see section 8 ==custom Validators, aync ops , asyn Validators etc...


 

 Continue with section 9..... 